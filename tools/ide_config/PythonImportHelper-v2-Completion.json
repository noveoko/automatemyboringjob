[
    {
        "label": "pyautogui",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pyautogui",
        "description": "pyautogui",
        "detail": "pyautogui",
        "documentation": {}
    },
    {
        "label": "sleep",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "pytesseract",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pytesseract",
        "description": "pytesseract",
        "detail": "pytesseract",
        "documentation": {}
    },
    {
        "label": "Output",
        "importPath": "pytesseract",
        "description": "pytesseract",
        "isExtraImport": true,
        "detail": "pytesseract",
        "documentation": {}
    },
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "cv2",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "cv2",
        "description": "cv2",
        "detail": "cv2",
        "documentation": {}
    },
    {
        "label": "pyttsx3",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pyttsx3",
        "description": "pyttsx3",
        "detail": "pyttsx3",
        "documentation": {}
    },
    {
        "label": "generateRegex",
        "importPath": "RegexGenerator.generateRegex",
        "description": "RegexGenerator.generateRegex",
        "isExtraImport": true,
        "detail": "RegexGenerator.generateRegex",
        "documentation": {}
    },
    {
        "label": "generateRegex",
        "importPath": "RegexGenerator.generateRegex",
        "description": "RegexGenerator.generateRegex",
        "isExtraImport": true,
        "detail": "RegexGenerator.generateRegex",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "click",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "click",
        "description": "click",
        "detail": "click",
        "documentation": {}
    },
    {
        "label": "UpdateFrequencies",
        "importPath": "utilities.create_symbol_frequency",
        "description": "utilities.create_symbol_frequency",
        "isExtraImport": true,
        "detail": "utilities.create_symbol_frequency",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timezone",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "glob",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "glob",
        "description": "glob",
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "datetime,pytz",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "datetime.pytz",
        "description": "datetime.pytz",
        "detail": "datetime.pytz",
        "documentation": {}
    },
    {
        "label": "say_this",
        "kind": 2,
        "importPath": "DesktopAutomation.fully_automate_desktop",
        "description": "DesktopAutomation.fully_automate_desktop",
        "peekOfCode": "def say_this(message):\n    engine = pyttsx3.init()\n    engine.say(message)\n    engine.runAndWait()\ndef click_on_coords_of_text_in_image(image_path, text_to_find):\n    # load the input image, convert it from BGR to RGB channel ordering,\n    # and use Tesseract to localize each area of text in the input image\n    image = cv2.imread(image_path)\n    rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n    results = pytesseract.image_to_data(rgb, output_type=Output.DICT)",
        "detail": "DesktopAutomation.fully_automate_desktop",
        "documentation": {}
    },
    {
        "label": "click_on_coords_of_text_in_image",
        "kind": 2,
        "importPath": "DesktopAutomation.fully_automate_desktop",
        "description": "DesktopAutomation.fully_automate_desktop",
        "peekOfCode": "def click_on_coords_of_text_in_image(image_path, text_to_find):\n    # load the input image, convert it from BGR to RGB channel ordering,\n    # and use Tesseract to localize each area of text in the input image\n    image = cv2.imread(image_path)\n    rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n    results = pytesseract.image_to_data(rgb, output_type=Output.DICT)\n    # loop over each of the individual text localizations\n    for i in range(0, len(results[\"text\"])):\n        # extract the bounding box coordinates of the text region from\n        # the current result",
        "detail": "DesktopAutomation.fully_automate_desktop",
        "documentation": {}
    },
    {
        "label": "test_generate_regex_pattern",
        "kind": 2,
        "importPath": "RegexGenerator.tests.test_all_features",
        "description": "RegexGenerator.tests.test_all_features",
        "peekOfCode": "def test_generate_regex_pattern():\n    g = generateRegex(\"abc\", \"100\")\n    assert g.string == \"abc\"\ndef test_generate_regex_pattern():\n    g = generateRegex(\"abc\", \"100\")\n    assert g.negative_string == \"100\"\ndef test_generate_regex_pattern():\n    g = generateRegex(\"abc\", \"100\")\n    assert g.symbol_map[\"#\"] == 0.015819750719079578\ndef test_generate_regex_pattern():",
        "detail": "RegexGenerator.tests.test_all_features",
        "documentation": {}
    },
    {
        "label": "test_generate_regex_pattern",
        "kind": 2,
        "importPath": "RegexGenerator.tests.test_all_features",
        "description": "RegexGenerator.tests.test_all_features",
        "peekOfCode": "def test_generate_regex_pattern():\n    g = generateRegex(\"abc\", \"100\")\n    assert g.negative_string == \"100\"\ndef test_generate_regex_pattern():\n    g = generateRegex(\"abc\", \"100\")\n    assert g.symbol_map[\"#\"] == 0.015819750719079578\ndef test_generate_regex_pattern():\n    g = generateRegex(\"abc\", \"100\")\n    assert g.generate_regex_pattern() == [[3, \"\\\\[q\"]]\ndef test_generate_regex_pattern():",
        "detail": "RegexGenerator.tests.test_all_features",
        "documentation": {}
    },
    {
        "label": "test_generate_regex_pattern",
        "kind": 2,
        "importPath": "RegexGenerator.tests.test_all_features",
        "description": "RegexGenerator.tests.test_all_features",
        "peekOfCode": "def test_generate_regex_pattern():\n    g = generateRegex(\"abc\", \"100\")\n    assert g.symbol_map[\"#\"] == 0.015819750719079578\ndef test_generate_regex_pattern():\n    g = generateRegex(\"abc\", \"100\")\n    assert g.generate_regex_pattern() == [[3, \"\\\\[q\"]]\ndef test_generate_regex_pattern():\n    g = generateRegex(\"abc\", \"100\")\n    g.generate_regex_from_string()\n    g.found_patterns = []",
        "detail": "RegexGenerator.tests.test_all_features",
        "documentation": {}
    },
    {
        "label": "test_generate_regex_pattern",
        "kind": 2,
        "importPath": "RegexGenerator.tests.test_all_features",
        "description": "RegexGenerator.tests.test_all_features",
        "peekOfCode": "def test_generate_regex_pattern():\n    g = generateRegex(\"abc\", \"100\")\n    assert g.generate_regex_pattern() == [[3, \"\\\\[q\"]]\ndef test_generate_regex_pattern():\n    g = generateRegex(\"abc\", \"100\")\n    g.generate_regex_from_string()\n    g.found_patterns = []\n# self.max_patterns = 5\n# self.max_tries = 1000\n# self.found_patterns = set()",
        "detail": "RegexGenerator.tests.test_all_features",
        "documentation": {}
    },
    {
        "label": "test_generate_regex_pattern",
        "kind": 2,
        "importPath": "RegexGenerator.tests.test_all_features",
        "description": "RegexGenerator.tests.test_all_features",
        "peekOfCode": "def test_generate_regex_pattern():\n    g = generateRegex(\"abc\", \"100\")\n    g.generate_regex_from_string()\n    g.found_patterns = []\n# self.max_patterns = 5\n# self.max_tries = 1000\n# self.found_patterns = set()\n# self.pattern_size: int = 3\n# self.unique_patterns: int = 1\n# self.symbol_map = uf.create_probability_object(uf)",
        "detail": "RegexGenerator.tests.test_all_features",
        "documentation": {}
    },
    {
        "label": "UpdateFrequencies",
        "kind": 6,
        "importPath": "RegexGenerator.utilities.create_symbol_frequency",
        "description": "RegexGenerator.utilities.create_symbol_frequency",
        "peekOfCode": "class UpdateFrequencies:\n    all_symbols = {\n        \".\": 0,\n        \"^\": 0,\n        \"$\": 0,\n        \"*\": 0,\n        \"+\": 0,\n        \"?\": 0,\n        \"{\": 0,\n        \"}\": 0,",
        "detail": "RegexGenerator.utilities.create_symbol_frequency",
        "documentation": {}
    },
    {
        "label": "patterns",
        "kind": 5,
        "importPath": "RegexGenerator.utilities.extract_patterns",
        "description": "RegexGenerator.utilities.extract_patterns",
        "peekOfCode": "patterns = set()\nwith open(\"scratchpad.txt\", \"r\", encoding=\"utf-8\") as infile:\n    for line in infile.readlines():\n        if \"re.compile\" in line:\n            line = line.split(\"re.compile\")[-1]\n            patterns.add(line)\nwith open(\"scratchpad.txt\", \"w\", encoding=\"utf-8\") as outfile:\n    for pattern in patterns:\n        outfile.write(pattern + \"\\n\")",
        "detail": "RegexGenerator.utilities.extract_patterns",
        "documentation": {}
    },
    {
        "label": "generateRegex",
        "kind": 6,
        "importPath": "RegexGenerator.generateRegex",
        "description": "RegexGenerator.generateRegex",
        "peekOfCode": "class generateRegex:\n    \"\"\"Generate a regex give a string\"\"\"\n    seed = 0.2323\n    def __init__(self, string: str = \"abc\", negative_string: str = \"10\"):\n        self.string = string\n        self.negative_string = negative_string\n        self.max_patterns = 2\n        self.max_tries = 10\n        self.found_patterns = set()\n        self.tried_patterns = []",
        "detail": "RegexGenerator.generateRegex",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "RegexGenerator.generateRegex",
        "description": "RegexGenerator.generateRegex",
        "peekOfCode": "def main(string, negative, mode):\n    \"\"\"Generate regex/string based on input\"\"\"\n    gen = generateRegex(string, negative)\n    result = None\n    if mode == \"regex\":\n        # generate regex from string\n        gen.generate_regex_from_string()\n        result = gen.found_patterns\n    elif mode == \"string\":\n        # generate string from regex",
        "detail": "RegexGenerator.generateRegex",
        "documentation": {}
    },
    {
        "label": "symbols",
        "kind": 5,
        "importPath": "RegexGenerator.word_generator",
        "description": "RegexGenerator.word_generator",
        "peekOfCode": "symbols = [r\"qazwsxedcrfvtgbyhnujmik,ol.;p['/]\\\\1234567890-=!@#$%^&*()_+{}|:?><\"]\nword = \"\"\nwhile len(word) < 5:\n    word += random.choice(symbols)\nprint(word)",
        "detail": "RegexGenerator.word_generator",
        "documentation": {}
    },
    {
        "label": "word",
        "kind": 5,
        "importPath": "RegexGenerator.word_generator",
        "description": "RegexGenerator.word_generator",
        "peekOfCode": "word = \"\"\nwhile len(word) < 5:\n    word += random.choice(symbols)\nprint(word)",
        "detail": "RegexGenerator.word_generator",
        "documentation": {}
    },
    {
        "label": "getTime",
        "kind": 2,
        "importPath": "Facebook_Messages_Report",
        "description": "Facebook_Messages_Report",
        "peekOfCode": "def getTime(milliseconds, timezone=\"US/Central\"):\n    dtobj2 = datetime.datetime.fromtimestamp(milliseconds/1000.0)\n    mytimezone=pytz.timezone(\"Europe/Warsaw\") #my current timezone\n    dtobj4=mytimezone.localize(dtobj2)        #localize function\n    new_timezone=dtobj4.astimezone(pytz.timezone(timezone)) #astimezone method\n    return [timezone, new_timezone.date(), new_timezone.time()]\ndef participants(list_of_people):\n    if len(list_of_people) > 4:\n        return f\"{list_of_people[0:4]}_...\"\n    else:",
        "detail": "Facebook_Messages_Report",
        "documentation": {}
    },
    {
        "label": "participants",
        "kind": 2,
        "importPath": "Facebook_Messages_Report",
        "description": "Facebook_Messages_Report",
        "peekOfCode": "def participants(list_of_people):\n    if len(list_of_people) > 4:\n        return f\"{list_of_people[0:4]}_...\"\n    else:\n        return list_of_people\ndef createMessageReport():\n    times = []\n    for file in files:\n        with open(file,'r',encoding='utf-8') as outfile:\n            j = json.load(outfile)",
        "detail": "Facebook_Messages_Report",
        "documentation": {}
    },
    {
        "label": "createMessageReport",
        "kind": 2,
        "importPath": "Facebook_Messages_Report",
        "description": "Facebook_Messages_Report",
        "peekOfCode": "def createMessageReport():\n    times = []\n    for file in files:\n        with open(file,'r',encoding='utf-8') as outfile:\n            j = json.load(outfile)\n            for message in j[\"messages\"]:\n                ms = int(message[\"timestamp_ms\"])\n                date = datetime.datetime.fromtimestamp(ms/1000.0)\n                sender = message[\"sender_name\"]\n                others = list(set([a[\"name\"] for a in j[\"participants\"]]))",
        "detail": "Facebook_Messages_Report",
        "documentation": {}
    },
    {
        "label": "files",
        "kind": 5,
        "importPath": "Facebook_Messages_Report",
        "description": "Facebook_Messages_Report",
        "peekOfCode": "files = glob.glob(\"**/*.json\")\nprint(files)\nimport datetime,pytz\ndef getTime(milliseconds, timezone=\"US/Central\"):\n    dtobj2 = datetime.datetime.fromtimestamp(milliseconds/1000.0)\n    mytimezone=pytz.timezone(\"Europe/Warsaw\") #my current timezone\n    dtobj4=mytimezone.localize(dtobj2)        #localize function\n    new_timezone=dtobj4.astimezone(pytz.timezone(timezone)) #astimezone method\n    return [timezone, new_timezone.date(), new_timezone.time()]\ndef participants(list_of_people):",
        "detail": "Facebook_Messages_Report",
        "documentation": {}
    },
    {
        "label": "extensions",
        "kind": 5,
        "importPath": "media",
        "description": "media",
        "peekOfCode": "extensions = [\n    \"psd\",\n    \"pdf\",\n    \"ai\",\n    \"indd\",\n    \"blend\",\n    \"tif\",\n    \"tiff\",\n    \"bmp\",\n    \"jpg\",",
        "detail": "media",
        "documentation": {}
    },
    {
        "label": "compressions",
        "kind": 5,
        "importPath": "media",
        "description": "media",
        "peekOfCode": "compressions = [\n    \"7z\",\n    \"s7z\",\n    \"ace\",\n    \"afa\",\n    \"alz\",\n    \"apk\",\n    \"arc\",\n    \"ark\",\n    \"arc\",",
        "detail": "media",
        "documentation": {}
    },
    {
        "label": "comps",
        "kind": 5,
        "importPath": "media",
        "description": "media",
        "peekOfCode": "comps = {a: set() for a in compressions}\nwith open(\"everyFile.txt\", \"r\", encoding=\"utf-8\") as infile:\n    for line in infile.readlines():\n        ext = line.split(\".\")[-1].strip()\n        if ext in extensions:\n            exts[ext].add(line)\n        if ext in compressions:\n            comps[ext].add(line)\nprint(\"FILES\")\nfor fileType, links in exts.items():",
        "detail": "media",
        "documentation": {}
    },
    {
        "label": "dimensions",
        "kind": 5,
        "importPath": "media",
        "description": "media",
        "peekOfCode": "dimensions = {\"small\": set(), \"medium\": set(), \"large\": set(), \"huge\": set()}\nfor fileType, links in comps.items():\n    if len(links) > 0:\n        for link in links:\n            link = link.strip()\n            try:\n                stats = os.stat(link)\n                size = stats.st_size / (1024 * 1024)\n                if 0 < size < 10:\n                    dimensions[\"small\"].add(link)",
        "detail": "media",
        "documentation": {}
    }
]